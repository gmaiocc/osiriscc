{"ast":null,"code":"'use strict';\n\n/* eslint-disable no-invalid-this,consistent-return*/\nconst paypalhttp = require('@paypal/paypalhttp');\nconst AccessToken = require('./access_token').AccessToken;\nconst AccessTokenRequest = require('./access_token_request').AccessTokenRequest;\nconst sdkVersion = require('../../package').version;\nconst TokenCache = require('./token_cache').TokenCache;\n\n/**\n * PayPal Http client\n */\nclass PayPalHttpClient extends paypalhttp.HttpClient {\n  /**\n   * @param {PayPalEnvironment} environment - The environment for this client\n   * @param {string} refreshToken - The refreshToken to be used to generate the access Token.\n   */\n  constructor(environment, refreshToken) {\n    super(environment);\n    this._cache = TokenCache.cacheForEnvironment(environment, refreshToken);\n    this.refreshToken = refreshToken;\n    this.addInjector(authInjector.bind(this));\n    this.addInjector(function (req) {\n      req.headers['Accept-Encoding'] = 'gzip';\n      req.headers[\"sdk_name\"] = \"Checkout SDK\";\n      req.headers[\"sdk_version\"] = \"1.0.3\";\n      req.headers[\"sdk_tech_stack\"] = \"NodeJS \" + process.version;\n      req.headers[\"api_integration_type\"] = \"PAYPALSDK\";\n    });\n  }\n\n  /**\n   * Returns the user agent for this client implementation\n   * @override\n   * @return {string} - The user agent string\n   */\n  getUserAgent() {\n    return 'PayPalSDK/PayPal-node-SDK ' + sdkVersion + ' (node ' + process.version + '-' + process.arch + '-' + process.platform + '; OpenSSL ' + process.versions.openssl + ')';\n  }\n  execute(request) {\n    return super.execute(request).catch(err => {\n      if (err.statusCode === 401) {\n        return this._retryRequest(request);\n      }\n      return Promise.reject(err);\n    });\n  }\n  _retryRequest(request) {\n    const promise = this._cache.wait(request).then(() => {\n      this._setAuthHeader(request);\n      return super.execute(request);\n    });\n    if (this._cache.isLocked()) {\n      return promise;\n    }\n\n    // Avoids node UnhandledPromiseRejectionWarning on access token failure.\n    return Promise.race([this.fetchAccessToken(), promise]).then(() => promise);\n  }\n  fetchAccessToken() {\n    this._cache.lock();\n    return super.execute(new AccessTokenRequest(this.environment, this.refreshToken)).then(resp => {\n      const token = new AccessToken(resp.result);\n      this._cache.setToken(token);\n      this._cache.notify();\n      this._cache.unlock();\n      return token;\n    }).catch(err => {\n      this._cache.setToken(null);\n      this._cache.notify(err);\n      this._cache.unlock();\n      return Promise.reject(err);\n    });\n  }\n\n  /**\n   * Sets the Authorization header for this request based on the client token\n   * @param {Object} request - The request to modify\n   * @private\n   * @return {void}\n   */\n  _setAuthHeader(request) {\n    const token = this._cache.getToken();\n    request.headers = request.headers || {};\n    request.headers.Authorization = token.authorizationString();\n  }\n}\n\n/**\n * An injector that fetches token when the client has no token or is expired and queues calls if the token is refreshing\n * @param {Object} request - The current request for the client\n * @return {Promise.<any>} Promise that fetches a new access Token\n */\nfunction authInjector(request) {\n  if (request.headers.Authorization) {\n    return;\n  }\n  if (this._cache.isValid()) {\n    this._setAuthHeader(request);\n  } else if (this._cache.isLocked()) {\n    return this._cache.wait(request).then(() => this._setAuthHeader(request));\n  } else if (!this._cache.isValid()) {\n    return Promise.all([this._cache.wait(request), this.fetchAccessToken()]).then(() => this._setAuthHeader(request));\n  }\n}\nmodule.exports = {\n  PayPalHttpClient: PayPalHttpClient\n};","map":{"version":3,"names":["paypalhttp","require","AccessToken","AccessTokenRequest","sdkVersion","version","TokenCache","PayPalHttpClient","HttpClient","constructor","environment","refreshToken","_cache","cacheForEnvironment","addInjector","authInjector","bind","req","headers","process","getUserAgent","arch","platform","versions","openssl","execute","request","catch","err","statusCode","_retryRequest","Promise","reject","promise","wait","then","_setAuthHeader","isLocked","race","fetchAccessToken","lock","resp","token","result","setToken","notify","unlock","getToken","Authorization","authorizationString","isValid","all","module","exports"],"sources":["C:/Users/gonca/my-app/node_modules/@paypal/checkout-server-sdk/lib/core/paypal_http_client.js"],"sourcesContent":["'use strict';\n/* eslint-disable no-invalid-this,consistent-return*/\n\nconst paypalhttp = require('@paypal/paypalhttp');\nconst AccessToken = require('./access_token').AccessToken;\nconst AccessTokenRequest = require('./access_token_request').AccessTokenRequest;\nconst sdkVersion = require('../../package').version;\nconst TokenCache = require('./token_cache').TokenCache;\n\n/**\n * PayPal Http client\n */\nclass PayPalHttpClient extends paypalhttp.HttpClient {\n\n  /**\n   * @param {PayPalEnvironment} environment - The environment for this client\n   * @param {string} refreshToken - The refreshToken to be used to generate the access Token.\n   */\n  constructor(environment, refreshToken) {\n    super(environment);\n\n    this._cache = TokenCache.cacheForEnvironment(environment, refreshToken);\n    this.refreshToken = refreshToken;\n    this.addInjector(authInjector.bind(this));\n    this.addInjector(function (req) {\n      req.headers['Accept-Encoding'] = 'gzip';\n      req.headers[\"sdk_name\"] = \"Checkout SDK\";\n      req.headers[\"sdk_version\"] = \"1.0.3\";\n      req.headers[\"sdk_tech_stack\"] = \"NodeJS \" + process.version;\n      req.headers[\"api_integration_type\"] = \"PAYPALSDK\";\n    });\n  }\n\n  /**\n   * Returns the user agent for this client implementation\n   * @override\n   * @return {string} - The user agent string\n   */\n  getUserAgent() {\n    return 'PayPalSDK/PayPal-node-SDK ' + sdkVersion + ' (node ' + process.version + '-' + process.arch + '-' + process.platform + '; OpenSSL ' + process.versions.openssl + ')';\n  }\n\n  execute(request) {\n    return super.execute(request).catch((err) => {\n      if (err.statusCode === 401) {\n        return this._retryRequest(request);\n      }\n      return Promise.reject(err);\n    });\n  }\n\n  _retryRequest(request) {\n    const promise = this._cache.wait(request).then(() => {\n      this._setAuthHeader(request);\n      return super.execute(request);\n    });\n\n    if (this._cache.isLocked()) {\n      return promise;\n    }\n\n    // Avoids node UnhandledPromiseRejectionWarning on access token failure.\n    return Promise.race([this.fetchAccessToken(), promise]).then(() => promise);\n  }\n\n  fetchAccessToken() {\n    this._cache.lock();\n    return super.execute(new AccessTokenRequest(this.environment, this.refreshToken)).then((resp) => {\n      const token = new AccessToken(resp.result);\n\n      this._cache.setToken(token);\n      this._cache.notify();\n      this._cache.unlock();\n      return token;\n    }).catch((err) => {\n      this._cache.setToken(null);\n      this._cache.notify(err);\n      this._cache.unlock();\n      return Promise.reject(err);\n    });\n  }\n\n  /**\n   * Sets the Authorization header for this request based on the client token\n   * @param {Object} request - The request to modify\n   * @private\n   * @return {void}\n   */\n  _setAuthHeader(request) {\n    const token = this._cache.getToken();\n\n    request.headers = request.headers || {};\n    request.headers.Authorization = token.authorizationString();\n  }\n}\n\n/**\n * An injector that fetches token when the client has no token or is expired and queues calls if the token is refreshing\n * @param {Object} request - The current request for the client\n * @return {Promise.<any>} Promise that fetches a new access Token\n */\nfunction authInjector(request) {\n  if (request.headers.Authorization) {\n    return;\n  }\n\n  if (this._cache.isValid()) {\n    this._setAuthHeader(request);\n  } else if (this._cache.isLocked()) {\n    return this._cache.wait(request).then(() => this._setAuthHeader(request));\n  } else if (!this._cache.isValid()) {\n    return Promise.all([\n      this._cache.wait(request),\n      this.fetchAccessToken()\n    ]).then(() => this._setAuthHeader(request));\n  }\n}\n\nmodule.exports = {\n  PayPalHttpClient: PayPalHttpClient\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}