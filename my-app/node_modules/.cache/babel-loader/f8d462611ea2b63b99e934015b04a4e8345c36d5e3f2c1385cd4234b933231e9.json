{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/gonca/Downloads/my-app/my-app/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"C:/Users/gonca/Downloads/my-app/my-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _createForOfIteratorHelper from \"C:/Users/gonca/Downloads/my-app/my-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _toConsumableArray from \"C:/Users/gonca/Downloads/my-app/my-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _objectSpread from \"C:/Users/gonca/Downloads/my-app/my-app/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _slicedToArray from \"C:/Users/gonca/Downloads/my-app/my-app/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport { useReducer as $d70Aq$useReducer, useEffect as $d70Aq$useEffect, useState as $d70Aq$useState, useMemo as $d70Aq$useMemo } from \"react\";\nfunction $0d86e9c8f07f9a7b$export$762f73dccccd255d(options) {\n  var _options$initialItems = options.initialItems,\n    initialItems = _options$initialItems === void 0 ? [] : _options$initialItems,\n    initialSelectedKeys = options.initialSelectedKeys,\n    _options$getKey = options.getKey,\n    getKey = _options$getKey === void 0 ? function (item) {\n      return item.id || item.key;\n    } : _options$getKey,\n    filter = options.filter,\n    _options$initialFilte = options.initialFilterText,\n    initialFilterText = _options$initialFilte === void 0 ? '' : _options$initialFilte;\n  // Store both items and filteredItems in state so we can go back to the unfiltered list\n  var _$d70Aq$useState = $d70Aq$useState({\n      items: initialItems,\n      selectedKeys: initialSelectedKeys === 'all' ? 'all' : new Set(initialSelectedKeys || []),\n      filterText: initialFilterText\n    }),\n    _$d70Aq$useState2 = _slicedToArray(_$d70Aq$useState, 2),\n    state = _$d70Aq$useState2[0],\n    setState = _$d70Aq$useState2[1];\n  var filteredItems = $d70Aq$useMemo(function () {\n    return filter ? state.items.filter(function (item) {\n      return filter(item, state.filterText);\n    }) : state.items;\n  }, [state.items, state.filterText, filter]);\n  return _objectSpread(_objectSpread(_objectSpread({}, state), {}, {\n    items: filteredItems\n  }, $0d86e9c8f07f9a7b$export$79c0c687a5963b0a({\n    getKey: getKey\n  }, setState)), {}, {\n    getItem: function getItem(key) {\n      return state.items.find(function (item) {\n        return getKey(item) === key;\n      });\n    }\n  });\n}\nfunction $0d86e9c8f07f9a7b$export$79c0c687a5963b0a(opts, dispatch) {\n  var cursor = opts.cursor,\n    getKey = opts.getKey;\n  return {\n    setSelectedKeys: function setSelectedKeys(selectedKeys) {\n      dispatch(function (state) {\n        return _objectSpread(_objectSpread({}, state), {}, {\n          selectedKeys: selectedKeys\n        });\n      });\n    },\n    setFilterText: function setFilterText(filterText) {\n      dispatch(function (state) {\n        return _objectSpread(_objectSpread({}, state), {}, {\n          filterText: filterText\n        });\n      });\n    },\n    insert: function insert(index) {\n      for (var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        values[_key - 1] = arguments[_key];\n      }\n      dispatch(function (state) {\n        return $0d86e9c8f07f9a7b$var$insert.apply(void 0, [state, index].concat(values));\n      });\n    },\n    insertBefore: function insertBefore(key) {\n      for (var _len2 = arguments.length, values = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        values[_key2 - 1] = arguments[_key2];\n      }\n      dispatch(function (state) {\n        var index = state.items.findIndex(function (item) {\n          return getKey(item) === key;\n        });\n        if (index === -1) return;\n        return $0d86e9c8f07f9a7b$var$insert.apply(void 0, [state, index].concat(values));\n      });\n    },\n    insertAfter: function insertAfter(key) {\n      for (var _len3 = arguments.length, values = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n        values[_key3 - 1] = arguments[_key3];\n      }\n      dispatch(function (state) {\n        var index = state.items.findIndex(function (item) {\n          return getKey(item) === key;\n        });\n        if (index === -1) return;\n        return $0d86e9c8f07f9a7b$var$insert.apply(void 0, [state, index + 1].concat(values));\n      });\n    },\n    prepend: function prepend() {\n      for (var _len4 = arguments.length, values = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        values[_key4] = arguments[_key4];\n      }\n      dispatch(function (state) {\n        return $0d86e9c8f07f9a7b$var$insert.apply(void 0, [state, 0].concat(values));\n      });\n    },\n    append: function append() {\n      for (var _len5 = arguments.length, values = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        values[_key5] = arguments[_key5];\n      }\n      dispatch(function (state) {\n        return $0d86e9c8f07f9a7b$var$insert.apply(void 0, [state, state.items.length].concat(values));\n      });\n    },\n    remove: function remove() {\n      for (var _len6 = arguments.length, keys = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        keys[_key6] = arguments[_key6];\n      }\n      dispatch(function (state) {\n        var keySet = new Set(keys);\n        var items = state.items.filter(function (item) {\n          return !keySet.has(getKey(item));\n        });\n        var selection = 'all';\n        if (state.selectedKeys !== 'all') {\n          selection = new Set(state.selectedKeys);\n          for (var _i = 0, _keys = keys; _i < _keys.length; _i++) {\n            var key = _keys[_i];\n            selection.delete(key);\n          }\n        }\n        if (cursor == null && items.length === 0) selection = new Set();\n        return _objectSpread(_objectSpread({}, state), {}, {\n          items: items,\n          selectedKeys: selection\n        });\n      });\n    },\n    removeSelectedItems: function removeSelectedItems() {\n      dispatch(function (state) {\n        if (state.selectedKeys === 'all') return _objectSpread(_objectSpread({}, state), {}, {\n          items: [],\n          selectedKeys: new Set()\n        });\n        var selectedKeys = state.selectedKeys;\n        var items = state.items.filter(function (item) {\n          return !selectedKeys.has(getKey(item));\n        });\n        return _objectSpread(_objectSpread({}, state), {}, {\n          items: items,\n          selectedKeys: new Set()\n        });\n      });\n    },\n    move: function move(key, toIndex) {\n      dispatch(function (state) {\n        var index = state.items.findIndex(function (item) {\n          return getKey(item) === key;\n        });\n        if (index === -1) return state;\n        var copy = state.items.slice();\n        var _copy$splice = copy.splice(index, 1),\n          _copy$splice2 = _slicedToArray(_copy$splice, 1),\n          item1 = _copy$splice2[0];\n        copy.splice(toIndex, 0, item1);\n        return _objectSpread(_objectSpread({}, state), {}, {\n          items: copy\n        });\n      });\n    },\n    moveBefore: function moveBefore(key1, keys) {\n      dispatch(function (state) {\n        var toIndex = state.items.findIndex(function (item) {\n          return getKey(item) === key1;\n        });\n        if (toIndex === -1) return state;\n        // Find indices of keys to move. Sort them so that the order in the list is retained.\n        var keyArray = Array.isArray(keys) ? keys : _toConsumableArray(keys);\n        var indices = keyArray.map(function (key) {\n          return state.items.findIndex(function (item) {\n            return getKey(item) === key;\n          });\n        }).sort();\n        return $0d86e9c8f07f9a7b$var$move(state, indices, toIndex);\n      });\n    },\n    moveAfter: function moveAfter(key2, keys) {\n      dispatch(function (state) {\n        var toIndex = state.items.findIndex(function (item) {\n          return getKey(item) === key2;\n        });\n        if (toIndex === -1) return state;\n        var keyArray = Array.isArray(keys) ? keys : _toConsumableArray(keys);\n        var indices = keyArray.map(function (key) {\n          return state.items.findIndex(function (item) {\n            return getKey(item) === key;\n          });\n        }).sort();\n        return $0d86e9c8f07f9a7b$var$move(state, indices, toIndex + 1);\n      });\n    },\n    update: function update(key, newValue) {\n      dispatch(function (state) {\n        var index = state.items.findIndex(function (item) {\n          return getKey(item) === key;\n        });\n        if (index === -1) return state;\n        return _objectSpread(_objectSpread({}, state), {}, {\n          items: [].concat(_toConsumableArray(state.items.slice(0, index)), [newValue], _toConsumableArray(state.items.slice(index + 1)))\n        });\n      });\n    }\n  };\n}\nfunction $0d86e9c8f07f9a7b$var$insert(state, index) {\n  for (var _len7 = arguments.length, values = new Array(_len7 > 2 ? _len7 - 2 : 0), _key7 = 2; _key7 < _len7; _key7++) {\n    values[_key7 - 2] = arguments[_key7];\n  }\n  return _objectSpread(_objectSpread({}, state), {}, {\n    items: [].concat(_toConsumableArray(state.items.slice(0, index)), values, _toConsumableArray(state.items.slice(index)))\n  });\n}\nfunction $0d86e9c8f07f9a7b$var$move(state, indices, toIndex) {\n  // Shift the target down by the number of items being moved from before the target\n  var _iterator = _createForOfIteratorHelper(indices),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var index = _step.value;\n      if (index < toIndex) toIndex--;\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  var moves = indices.map(function (from) {\n    return {\n      from: from,\n      to: toIndex++\n    };\n  });\n  // Shift later from indices down if they have a larger index\n  for (var i = 0; i < moves.length; i++) {\n    var a = moves[i].from;\n    for (var j = i; j < moves.length; j++) {\n      var b = moves[j].from;\n      if (b > a) moves[j].from--;\n    }\n  }\n  // Interleave the moves so they can be applied one by one rather than all at once\n  for (var i1 = 0; i1 < moves.length; i1++) {\n    var _a = moves[i1];\n    for (var _j = moves.length - 1; _j > i1; _j--) {\n      var _b = moves[_j];\n      if (_b.from < _a.to) _a.to++;else _b.from++;\n    }\n  }\n  var copy = state.items.slice();\n  var _iterator2 = _createForOfIteratorHelper(moves),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var move = _step2.value;\n      var _copy$splice3 = copy.splice(move.from, 1),\n        _copy$splice4 = _slicedToArray(_copy$splice3, 1),\n        item = _copy$splice4[0];\n      copy.splice(move.to, 0, item);\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  return _objectSpread(_objectSpread({}, state), {}, {\n    items: copy\n  });\n}\nfunction $f86e6c1ec7da6ebb$var$reducer(data, action) {\n  var selectedKeys;\n  switch (data.state) {\n    case 'idle':\n    case 'error':\n      switch (action.type) {\n        case 'loading':\n        case 'loadingMore':\n        case 'sorting':\n        case 'filtering':\n          var _filterText, _sortDescriptor;\n          return _objectSpread(_objectSpread({}, data), {}, {\n            filterText: (_filterText = action.filterText) !== null && _filterText !== void 0 ? _filterText : data.filterText,\n            state: action.type,\n            // Reset items to an empty list if loading, but not when sorting.\n            items: action.type === 'loading' ? [] : data.items,\n            sortDescriptor: (_sortDescriptor = action.sortDescriptor) !== null && _sortDescriptor !== void 0 ? _sortDescriptor : data.sortDescriptor,\n            abortController: action.abortController\n          });\n        case 'update':\n          return _objectSpread(_objectSpread({}, data), action.updater(data));\n        case 'success':\n        case 'error':\n          return data;\n        default:\n          throw new Error(\"Invalid action \\\"\".concat(action.type, \"\\\" in state \\\"\").concat(data.state, \"\\\"\"));\n      }\n    case 'loading':\n    case 'sorting':\n    case 'filtering':\n      switch (action.type) {\n        case 'success':\n          // Ignore if there is a newer abortcontroller in state.\n          // This means that multiple requests were going at once.\n          // We want to take only the latest result.\n          if (action.abortController !== data.abortController) return data;\n          var _selectedKeys;\n          selectedKeys = (_selectedKeys = action.selectedKeys) !== null && _selectedKeys !== void 0 ? _selectedKeys : data.selectedKeys;\n          var _filterText1, _sortDescriptor1;\n          return _objectSpread(_objectSpread({}, data), {}, {\n            filterText: (_filterText1 = action.filterText) !== null && _filterText1 !== void 0 ? _filterText1 : data.filterText,\n            state: 'idle',\n            items: _toConsumableArray(action.items),\n            selectedKeys: selectedKeys === 'all' ? 'all' : new Set(selectedKeys),\n            sortDescriptor: (_sortDescriptor1 = action.sortDescriptor) !== null && _sortDescriptor1 !== void 0 ? _sortDescriptor1 : data.sortDescriptor,\n            abortController: null,\n            cursor: action.cursor\n          });\n        case 'error':\n          if (action.abortController !== data.abortController) return data;\n          return _objectSpread(_objectSpread({}, data), {}, {\n            state: 'error',\n            error: action.error,\n            abortController: null\n          });\n        case 'loading':\n        case 'loadingMore':\n        case 'sorting':\n        case 'filtering':\n          // We're already loading, and another load was triggered at the same time.\n          // We need to abort the previous load and start a new one.\n          data.abortController.abort();\n          var _filterText2;\n          return _objectSpread(_objectSpread({}, data), {}, {\n            filterText: (_filterText2 = action.filterText) !== null && _filterText2 !== void 0 ? _filterText2 : data.filterText,\n            state: action.type,\n            // Reset items to an empty list if loading, but not when sorting.\n            items: action.type === 'loading' ? [] : data.items,\n            abortController: action.abortController\n          });\n        case 'update':\n          // We're already loading, and an update happened at the same time (e.g. selectedKey changed).\n          // Update data but don't abort previous load.\n          return _objectSpread(_objectSpread({}, data), action.updater(data));\n        default:\n          throw new Error(\"Invalid action \\\"\".concat(action.type, \"\\\" in state \\\"\").concat(data.state, \"\\\"\"));\n      }\n    case 'loadingMore':\n      switch (action.type) {\n        case 'success':\n          var _selectedKeys1;\n          selectedKeys = data.selectedKeys === 'all' || action.selectedKeys === 'all' ? 'all' : new Set([].concat(_toConsumableArray(data.selectedKeys), _toConsumableArray((_selectedKeys1 = action.selectedKeys) !== null && _selectedKeys1 !== void 0 ? _selectedKeys1 : [])));\n          var _sortDescriptor2;\n          // Append the new items\n          return _objectSpread(_objectSpread({}, data), {}, {\n            state: 'idle',\n            items: [].concat(_toConsumableArray(data.items), _toConsumableArray(action.items)),\n            selectedKeys: selectedKeys,\n            sortDescriptor: (_sortDescriptor2 = action.sortDescriptor) !== null && _sortDescriptor2 !== void 0 ? _sortDescriptor2 : data.sortDescriptor,\n            abortController: null,\n            cursor: action.cursor\n          });\n        case 'error':\n          if (action.abortController !== data.abortController) return data;\n          return _objectSpread(_objectSpread({}, data), {}, {\n            state: 'error',\n            error: action.error\n          });\n        case 'loading':\n        case 'sorting':\n        case 'filtering':\n          // We're already loading more, and another load was triggered at the same time.\n          // We need to abort the previous load more and start a new one.\n          data.abortController.abort();\n          var _filterText3;\n          return _objectSpread(_objectSpread({}, data), {}, {\n            filterText: (_filterText3 = action.filterText) !== null && _filterText3 !== void 0 ? _filterText3 : data.filterText,\n            state: action.type,\n            // Reset items to an empty list if loading, but not when sorting.\n            items: action.type === 'loading' ? [] : data.items,\n            abortController: action.abortController\n          });\n        case 'loadingMore':\n          // If already loading more and another loading more is triggered, abort the new load more since\n          // it is a duplicate request since the cursor hasn't been updated.\n          // Do not overwrite the data.abortController\n          action.abortController.abort();\n          return data;\n        case 'update':\n          // We're already loading, and an update happened at the same time (e.g. selectedKey changed).\n          // Update data but don't abort previous load.\n          return _objectSpread(_objectSpread({}, data), action.updater(data));\n        default:\n          throw new Error(\"Invalid action \\\"\".concat(action.type, \"\\\" in state \\\"\").concat(data.state, \"\\\"\"));\n      }\n    default:\n      throw new Error(\"Invalid state \\\"\".concat(data.state, \"\\\"\"));\n  }\n}\nfunction $f86e6c1ec7da6ebb$export$bc3384a35de93d66(options) {\n  var load = options.load,\n    _sort = options.sort,\n    initialSelectedKeys = options.initialSelectedKeys,\n    initialSortDescriptor = options.initialSortDescriptor,\n    _options$getKey2 = options.getKey,\n    getKey = _options$getKey2 === void 0 ? function (item) {\n      return item.id || item.key;\n    } : _options$getKey2,\n    _options$initialFilte2 = options.initialFilterText,\n    initialFilterText = _options$initialFilte2 === void 0 ? '' : _options$initialFilte2;\n  var _$d70Aq$useReducer = $d70Aq$useReducer($f86e6c1ec7da6ebb$var$reducer, {\n      state: 'idle',\n      error: null,\n      items: [],\n      selectedKeys: initialSelectedKeys === 'all' ? 'all' : new Set(initialSelectedKeys),\n      sortDescriptor: initialSortDescriptor,\n      filterText: initialFilterText\n    }),\n    _$d70Aq$useReducer2 = _slicedToArray(_$d70Aq$useReducer, 2),\n    data = _$d70Aq$useReducer2[0],\n    dispatch = _$d70Aq$useReducer2[1];\n  var dispatchFetch = /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(action, fn) {\n      var abortController, _filterText, previousFilterText, _sortDescriptor, response, _filterText4, filterText;\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            abortController = new AbortController();\n            _context.prev = 1;\n            dispatch(_objectSpread(_objectSpread({}, action), {}, {\n              abortController: abortController\n            }));\n            previousFilterText = (_filterText = action.filterText) !== null && _filterText !== void 0 ? _filterText : data.filterText;\n            _context.next = 6;\n            return fn({\n              items: data.items.slice(),\n              selectedKeys: data.selectedKeys,\n              sortDescriptor: (_sortDescriptor = action.sortDescriptor) !== null && _sortDescriptor !== void 0 ? _sortDescriptor : data.sortDescriptor,\n              signal: abortController.signal,\n              cursor: action.type === 'loadingMore' ? data.cursor : null,\n              filterText: previousFilterText\n            });\n          case 6:\n            response = _context.sent;\n            filterText = (_filterText4 = response.filterText) !== null && _filterText4 !== void 0 ? _filterText4 : previousFilterText;\n            dispatch(_objectSpread(_objectSpread({\n              type: 'success'\n            }, response), {}, {\n              abortController: abortController\n            }));\n            // Fetch a new filtered list if filterText is updated via `load` response func rather than list.setFilterText\n            // Only do this if not aborted (e.g. user triggers another filter action before load completes)\n            if (filterText && filterText !== previousFilterText && !abortController.signal.aborted) dispatchFetch({\n              type: 'filtering',\n              filterText: filterText\n            }, load);\n            _context.next = 15;\n            break;\n          case 12:\n            _context.prev = 12;\n            _context.t0 = _context[\"catch\"](1);\n            dispatch({\n              type: 'error',\n              error: _context.t0,\n              abortController: abortController\n            });\n          case 15:\n          case \"end\":\n            return _context.stop();\n        }\n      }, _callee, null, [[1, 12]]);\n    }));\n    return function dispatchFetch(_x, _x2) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n  $d70Aq$useEffect(function () {\n    dispatchFetch({\n      type: 'loading'\n    }, load);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  return _objectSpread(_objectSpread({\n    items: data.items,\n    selectedKeys: data.selectedKeys,\n    sortDescriptor: data.sortDescriptor,\n    isLoading: data.state === 'loading' || data.state === 'loadingMore' || data.state === 'sorting' || data.state === 'filtering',\n    loadingState: data.state,\n    error: data.error,\n    filterText: data.filterText,\n    getItem: function getItem(key) {\n      return data.items.find(function (item) {\n        return getKey(item) === key;\n      });\n    },\n    reload: function reload() {\n      dispatchFetch({\n        type: 'loading'\n      }, load);\n    },\n    loadMore: function loadMore() {\n      // Ignore if already loading more or if performing server side filtering.\n      if (data.state === 'loadingMore' || data.state === 'filtering' || data.cursor == null) return;\n      dispatchFetch({\n        type: 'loadingMore'\n      }, load);\n    },\n    sort: function sort(sortDescriptor) {\n      dispatchFetch({\n        type: 'sorting',\n        sortDescriptor: sortDescriptor\n      }, _sort || load);\n    }\n  }, $0d86e9c8f07f9a7b$export$79c0c687a5963b0a(_objectSpread(_objectSpread({}, options), {}, {\n    getKey: getKey,\n    cursor: data.cursor\n  }), function (fn) {\n    dispatch({\n      type: 'update',\n      updater: fn\n    });\n  })), {}, {\n    setFilterText: function setFilterText(filterText) {\n      dispatchFetch({\n        type: 'filtering',\n        filterText: filterText\n      }, load);\n    }\n  });\n}\nfunction $be2ea0343af54212$export$d14e1352e21f4a16(options) {\n  var _options$initialItems2 = options.initialItems,\n    initialItems1 = _options$initialItems2 === void 0 ? [] : _options$initialItems2,\n    initialSelectedKeys = options.initialSelectedKeys,\n    _options$getKey3 = options.getKey,\n    getKey = _options$getKey3 === void 0 ? function (item) {\n      return item.id || item.key;\n    } : _options$getKey3,\n    _options$getChildren = options.getChildren,\n    getChildren = _options$getChildren === void 0 ? function (item) {\n      return item.children;\n    } : _options$getChildren;\n  var map = $d70Aq$useMemo(function () {\n    return new Map();\n  }, []);\n  // We only want to compute this on initial render.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  var initialNodes = $d70Aq$useMemo(function () {\n    return buildTree(initialItems1);\n  }, []);\n  var _$d70Aq$useState3 = $d70Aq$useState(initialNodes),\n    _$d70Aq$useState4 = _slicedToArray(_$d70Aq$useState3, 2),\n    items1 = _$d70Aq$useState4[0],\n    setItems = _$d70Aq$useState4[1];\n  var _$d70Aq$useState5 = $d70Aq$useState(new Set(initialSelectedKeys || [])),\n    _$d70Aq$useState6 = _slicedToArray(_$d70Aq$useState5, 2),\n    selectedKeys = _$d70Aq$useState6[0],\n    setSelectedKeys = _$d70Aq$useState6[1];\n  function buildTree() {\n    var initialItems = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    var parentKey = arguments.length > 1 ? arguments[1] : undefined;\n    return initialItems.map(function (item) {\n      var node = {\n        key: getKey(item),\n        parentKey: parentKey,\n        value: item,\n        children: null\n      };\n      node.children = buildTree(getChildren(item), node.key);\n      map.set(node.key, node);\n      return node;\n    });\n  }\n  function updateTree(items, key, update) {\n    var node = map.get(key);\n    if (!node) return items;\n    // Create a new node. If null, then delete the node, otherwise replace.\n    var newNode = update(node);\n    if (newNode == null) deleteNode(node);else addNode(newNode);\n    // Walk up the tree and update each parent to refer to the new chilren.\n    while (node.parentKey) {\n      var nextParent = map.get(node.parentKey);\n      var copy = {\n        key: nextParent.key,\n        parentKey: nextParent.parentKey,\n        value: nextParent.value,\n        children: null\n      };\n      var children = nextParent.children;\n      if (newNode == null) children = children.filter(function (c) {\n        return c !== node;\n      });\n      copy.children = children.map(function (child) {\n        if (child === node) return newNode;\n        return child;\n      });\n      map.set(copy.key, copy);\n      newNode = copy;\n      node = nextParent;\n    }\n    if (newNode == null) items = items.filter(function (c) {\n      return c !== node;\n    });\n    return items.map(function (item) {\n      if (item === node) return newNode;\n      return item;\n    });\n  }\n  function addNode(node) {\n    map.set(node.key, node);\n    var _iterator3 = _createForOfIteratorHelper(node.children),\n      _step3;\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var child = _step3.value;\n        addNode(child);\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n  }\n  function deleteNode(node) {\n    map.delete(node.key);\n    var _iterator4 = _createForOfIteratorHelper(node.children),\n      _step4;\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var child = _step4.value;\n        deleteNode(child);\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n  }\n  return {\n    items: items1,\n    selectedKeys: selectedKeys,\n    setSelectedKeys: setSelectedKeys,\n    getItem: function getItem(key) {\n      return map.get(key);\n    },\n    insert: function insert(parentKey, index) {\n      for (var _len8 = arguments.length, values = new Array(_len8 > 2 ? _len8 - 2 : 0), _key8 = 2; _key8 < _len8; _key8++) {\n        values[_key8 - 2] = arguments[_key8];\n      }\n      setItems(function (items) {\n        var nodes = buildTree(values, parentKey);\n        // If parentKey is null, insert into the root.\n        if (parentKey == null) return [].concat(_toConsumableArray(items.slice(0, index)), _toConsumableArray(nodes), _toConsumableArray(items.slice(index)));\n        // Otherwise, update the parent node and its ancestors.\n        return updateTree(items, parentKey, function (parentNode) {\n          return {\n            key: parentNode.key,\n            parentKey: parentNode.parentKey,\n            value: parentNode.value,\n            children: [].concat(_toConsumableArray(parentNode.children.slice(0, index)), _toConsumableArray(nodes), _toConsumableArray(parentNode.children.slice(index)))\n          };\n        });\n      });\n    },\n    insertBefore: function insertBefore(key) {\n      var node = map.get(key);\n      if (!node) return;\n      var parentNode = map.get(node.parentKey);\n      var nodes = parentNode ? parentNode.children : items1;\n      var index = nodes.indexOf(node);\n      for (var _len9 = arguments.length, values = new Array(_len9 > 1 ? _len9 - 1 : 0), _key9 = 1; _key9 < _len9; _key9++) {\n        values[_key9 - 1] = arguments[_key9];\n      }\n      this.insert.apply(this, [parentNode === null || parentNode === void 0 ? void 0 : parentNode.key, index].concat(values));\n    },\n    insertAfter: function insertAfter(key) {\n      var node = map.get(key);\n      if (!node) return;\n      var parentNode = map.get(node.parentKey);\n      var nodes = parentNode ? parentNode.children : items1;\n      var index = nodes.indexOf(node);\n      for (var _len10 = arguments.length, values = new Array(_len10 > 1 ? _len10 - 1 : 0), _key10 = 1; _key10 < _len10; _key10++) {\n        values[_key10 - 1] = arguments[_key10];\n      }\n      this.insert.apply(this, [parentNode === null || parentNode === void 0 ? void 0 : parentNode.key, index + 1].concat(values));\n    },\n    prepend: function prepend(parentKey) {\n      for (var _len11 = arguments.length, values = new Array(_len11 > 1 ? _len11 - 1 : 0), _key11 = 1; _key11 < _len11; _key11++) {\n        values[_key11 - 1] = arguments[_key11];\n      }\n      this.insert.apply(this, [parentKey, 0].concat(values));\n    },\n    append: function append(parentKey) {\n      for (var _len12 = arguments.length, values = new Array(_len12 > 1 ? _len12 - 1 : 0), _key12 = 1; _key12 < _len12; _key12++) {\n        values[_key12 - 1] = arguments[_key12];\n      }\n      if (parentKey == null) this.insert.apply(this, [null, items1.length].concat(values));else {\n        var parentNode = map.get(parentKey);\n        if (!parentNode) return;\n        this.insert.apply(this, [parentKey, parentNode.children.length].concat(values));\n      }\n    },\n    remove: function remove() {\n      var newItems = items1;\n      for (var _len13 = arguments.length, keys = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {\n        keys[_key13] = arguments[_key13];\n      }\n      for (var _i2 = 0, _keys2 = keys; _i2 < _keys2.length; _i2++) {\n        var key = _keys2[_i2];\n        newItems = updateTree(newItems, key, function () {\n          return null;\n        });\n      }\n      setItems(newItems);\n      var selection = new Set(selectedKeys);\n      var _iterator5 = _createForOfIteratorHelper(selectedKeys),\n        _step5;\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var key1 = _step5.value;\n          if (!map.has(key1)) selection.delete(key1);\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n      setSelectedKeys(selection);\n    },\n    removeSelectedItems: function removeSelectedItems() {\n      this.remove.apply(this, _toConsumableArray(selectedKeys));\n    },\n    move: function move(key, toParentKey, index) {\n      setItems(function (items) {\n        var node = map.get(key);\n        if (!node) return items;\n        items = updateTree(items, key, function () {\n          return null;\n        });\n        var movedNode = _objectSpread(_objectSpread({}, node), {}, {\n          parentKey: toParentKey\n        });\n        return updateTree(items, toParentKey, function (parentNode) {\n          return {\n            key: parentNode.key,\n            parentKey: parentNode.parentKey,\n            value: parentNode.value,\n            children: [].concat(_toConsumableArray(parentNode.children.slice(0, index)), [movedNode], _toConsumableArray(parentNode.children.slice(index)))\n          };\n        });\n      });\n    },\n    update: function update(oldKey, newValue) {\n      setItems(function (items) {\n        return updateTree(items, oldKey, function (oldNode) {\n          var node = {\n            key: oldNode.key,\n            parentKey: oldNode.parentKey,\n            value: newValue,\n            children: null\n          };\n          node.children = buildTree(getChildren(newValue), node.key);\n          return node;\n        });\n      });\n    }\n  };\n}\nexport { $f86e6c1ec7da6ebb$export$bc3384a35de93d66 as useAsyncList, $be2ea0343af54212$export$d14e1352e21f4a16 as useTreeData, $0d86e9c8f07f9a7b$export$762f73dccccd255d as useListData };","map":{"version":3,"mappings":"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","names":["$0d86e9c8f07f9a7b$export$762f73dccccd255d","options","initialItems","initialSelectedKeys","getKey","item","id","key","filter","initialFilterText","$d70Aq$useState","items","selectedKeys","Set","filterText","state","setState","filteredItems","$d70Aq$useMemo","$0d86e9c8f07f9a7b$export$79c0c687a5963b0a","getItem","find","opts","dispatch","cursor","setSelectedKeys","setFilterText","insert","index","values","$0d86e9c8f07f9a7b$var$insert","insertBefore","findIndex","insertAfter","prepend","append","length","remove","keys","keySet","has","selection","delete","removeSelectedItems","move","toIndex","copy","slice","splice","item1","moveBefore","key1","keyArray","Array","isArray","indices","map","sort","$0d86e9c8f07f9a7b$var$move","moveAfter","key2","update","newValue","moves","from","to","i","a","j","b","i1","$f86e6c1ec7da6ebb$var$reducer","data","action","type","_filterText","_sortDescriptor","sortDescriptor","abortController","updater","Error","_selectedKeys","_filterText1","_sortDescriptor1","error","abort","_filterText2","_selectedKeys1","_sortDescriptor2","_filterText3","$f86e6c1ec7da6ebb$export$bc3384a35de93d66","load","initialSortDescriptor","$d70Aq$useReducer","dispatchFetch","fn","AbortController","previousFilterText","signal","response","_filterText4","aborted","$d70Aq$useEffect","isLoading","loadingState","reload","loadMore","$be2ea0343af54212$export$d14e1352e21f4a16","initialItems1","getChildren","children","Map","initialNodes","buildTree","items1","setItems","parentKey","node","value","set","updateTree","get","newNode","deleteNode","addNode","nextParent","c","child","nodes","parentNode","indexOf","newItems","toParentKey","movedNode","oldKey","oldNode"],"sources":["C:\\Users\\gonca\\Downloads\\my-app\\my-app\\node_modules\\@react-stately\\data\\dist\\packages\\@react-stately\\data\\src\\useListData.ts","C:\\Users\\gonca\\Downloads\\my-app\\my-app\\node_modules\\@react-stately\\data\\dist\\packages\\@react-stately\\data\\src\\useAsyncList.ts","C:\\Users\\gonca\\Downloads\\my-app\\my-app\\node_modules\\@react-stately\\data\\dist\\packages\\@react-stately\\data\\src\\useTreeData.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Key, useMemo, useState} from 'react';\nimport {Selection} from '@react-types/shared';\n\nexport interface ListOptions<T> {\n  /** Initial items in the list. */\n  initialItems?: T[],\n  /** The keys for the initially selected items. */\n  initialSelectedKeys?: 'all' | Iterable<Key>,\n  /** The initial text to filter the list by. */\n  initialFilterText?: string,\n  /** A function that returns a unique key for an item object. */\n  getKey?: (item: T) => Key,\n  /** A function that returns whether a item matches the current filter text. */\n  filter?: (item: T, filterText: string) => boolean\n}\n\nexport interface ListData<T> {\n  /** The items in the list. */\n  items: T[],\n\n  /** The keys of the currently selected items in the list. */\n  selectedKeys: Selection,\n\n  /** Sets the selected keys. */\n  setSelectedKeys(keys: Selection): void,\n\n  /** The current filter text. */\n  filterText: string,\n\n  /** Sets the filter text. */\n  setFilterText(filterText: string): void,\n\n  /**\n   * Gets an item from the list by key.\n   * @param key - The key of the item to retrieve.\n   */\n  getItem(key: Key): T,\n\n  /**\n   * Inserts items into the list at the given index.\n   * @param index - The index to insert into.\n   * @param values - The values to insert.\n   */\n  insert(index: number, ...values: T[]): void,\n\n  /**\n   * Inserts items into the list before the item at the given key.\n   * @param key - The key of the item to insert before.\n   * @param values - The values to insert.\n   */\n  insertBefore(key: Key, ...values: T[]): void,\n\n  /**\n   * Inserts items into the list after the item at the given key.\n   * @param key - The key of the item to insert after.\n   * @param values - The values to insert.\n   */\n  insertAfter(key: Key, ...values: T[]): void,\n\n  /**\n   * Appends items to the list.\n   * @param values - The values to insert.\n   */\n  append(...values: T[]): void,\n\n  /**\n   * Prepends items to the list.\n   * @param value - The value to insert.\n   */\n  prepend(...values: T[]): void,\n\n  /**\n   * Removes items from the list by their keys.\n   * @param keys - The keys of the item to remove.\n   */\n  remove(...keys: Key[]): void,\n\n  /**\n   * Removes all items from the list that are currently\n   * in the set of selected items.\n   */\n  removeSelectedItems(): void,\n\n  /**\n   * Moves an item within the list.\n   * @param key - The key of the item to move.\n   * @param toIndex - The index to move the item to.\n   */\n  move(key: Key, toIndex: number): void,\n\n  /**\n   * Moves one or more items before a given key.\n   * @param key - The key of the item to move the items before.\n   * @param keys - The keys of the items to move.\n   */\n  moveBefore(key: Key, keys: Iterable<Key>): void,\n\n  /**\n   * Moves one or more items after a given key.\n   * @param key - The key of the item to move the items after.\n   * @param keys - The keys of the items to move.\n   */\n  moveAfter(key: Key, keys: Iterable<Key>): void,\n\n  /**\n   * Updates an item in the list.\n   * @param key - The key of the item to update.\n   * @param newValue - The new value for the item.\n   */\n  update(key: Key, newValue: T): void\n}\n\nexport interface ListState<T> {\n  items: T[],\n  selectedKeys: Selection,\n  filterText: string\n}\n\ninterface CreateListOptions<T, C> extends ListOptions<T> {\n  cursor?: C\n}\n\n/**\n * Manages state for an immutable list data structure, and provides convenience methods to\n * update the data over time.\n */\nexport function useListData<T>(options: ListOptions<T>): ListData<T> {\n  let {\n    initialItems = [],\n    initialSelectedKeys,\n    getKey = (item: any) => item.id || item.key,\n    filter,\n    initialFilterText = ''\n  } = options;\n\n  // Store both items and filteredItems in state so we can go back to the unfiltered list\n  let [state, setState] = useState<ListState<T>>({\n    items: initialItems,\n    selectedKeys: initialSelectedKeys === 'all' ? 'all' : new Set(initialSelectedKeys || []),\n    filterText: initialFilterText\n  });\n\n  let filteredItems = useMemo(\n    () => filter ? state.items.filter(item => filter(item, state.filterText)) : state.items,\n    [state.items, state.filterText, filter]);\n\n  return {\n    ...state,\n    items: filteredItems,\n    ...createListActions({getKey}, setState),\n    getItem(key: Key) {\n      return state.items.find(item => getKey(item) === key);\n    }\n  };\n}\n\nexport function createListActions<T, C>(opts: CreateListOptions<T, C>, dispatch: (updater: (state: ListState<T>) => ListState<T>) => void): Omit<ListData<T>, 'items' | 'selectedKeys' | 'getItem' | 'filterText'> {\n  let {cursor, getKey} = opts;\n  return {\n    setSelectedKeys(selectedKeys: Selection) {\n      dispatch(state => ({\n        ...state,\n        selectedKeys\n      }));\n    },\n    setFilterText(filterText: string) {\n      dispatch(state => ({\n        ...state,\n        filterText\n      }));\n    },\n    insert(index: number, ...values: T[]) {\n      dispatch(state => insert(state, index, ...values));\n    },\n    insertBefore(key: Key, ...values: T[]) {\n      dispatch(state => {\n        let index = state.items.findIndex(item => getKey(item) === key);\n        if (index === -1) {\n          return;\n        }\n\n        return insert(state, index, ...values);\n      });\n    },\n    insertAfter(key: Key, ...values: T[]) {\n      dispatch(state => {\n        let index = state.items.findIndex(item => getKey(item) === key);\n        if (index === -1) {\n          return;\n        }\n\n        return insert(state, index + 1, ...values);\n      });\n    },\n    prepend(...values: T[]) {\n      dispatch(state => insert(state, 0, ...values));\n    },\n    append(...values: T[]) {\n      dispatch(state => insert(state, state.items.length, ...values));\n    },\n    remove(...keys: Key[]) {\n      dispatch(state => {\n        let keySet = new Set(keys);\n        let items = state.items.filter(item => !keySet.has(getKey(item)));\n\n        let selection: Selection = 'all';\n        if (state.selectedKeys !== 'all') {\n          selection = new Set(state.selectedKeys);\n          for (let key of keys) {\n            selection.delete(key);\n          }\n        }\n        if (cursor == null && items.length === 0) {\n          selection = new Set();\n        }\n\n        return {\n          ...state,\n          items,\n          selectedKeys: selection\n        };\n      });\n    },\n    removeSelectedItems() {\n      dispatch(state => {\n        if (state.selectedKeys === 'all') {\n          return {\n            ...state,\n            items: [],\n            selectedKeys: new Set()\n          };\n        }\n\n        let selectedKeys = state.selectedKeys;\n        let items = state.items.filter(item => !selectedKeys.has(getKey(item)));\n        return {\n          ...state,\n          items,\n          selectedKeys: new Set()\n        };\n      });\n    },\n    move(key: Key, toIndex: number) {\n      dispatch(state => {\n        let index = state.items.findIndex(item => getKey(item) === key);\n        if (index === -1) {\n          return state;\n        }\n\n        let copy = state.items.slice();\n        let [item] = copy.splice(index, 1);\n        copy.splice(toIndex, 0, item);\n        return {\n          ...state,\n          items: copy\n        };\n      });\n    },\n    moveBefore(key: Key, keys: Iterable<Key>) {\n      dispatch(state => {\n        let toIndex = state.items.findIndex(item => getKey(item) === key);\n        if (toIndex === -1) {\n          return state;\n        }\n\n        // Find indices of keys to move. Sort them so that the order in the list is retained.\n        let keyArray = Array.isArray(keys) ? keys : [...keys];\n        let indices = keyArray.map(key => state.items.findIndex(item => getKey(item) === key)).sort();\n        return move(state, indices, toIndex);\n      });\n    },\n    moveAfter(key: Key, keys: Iterable<Key>) {\n      dispatch(state => {\n        let toIndex = state.items.findIndex(item => getKey(item) === key);\n        if (toIndex === -1) {\n          return state;\n        }\n\n        let keyArray = Array.isArray(keys) ? keys : [...keys];\n        let indices = keyArray.map(key => state.items.findIndex(item => getKey(item) === key)).sort();\n        return move(state, indices, toIndex + 1);\n      });\n    },\n    update(key: Key, newValue: T) {\n      dispatch(state => {\n        let index = state.items.findIndex(item => getKey(item) === key);\n        if (index === -1) {\n          return state;\n        }\n\n        return {\n          ...state,\n          items: [\n            ...state.items.slice(0, index),\n            newValue,\n            ...state.items.slice(index + 1)\n          ]\n        };\n      });\n    }\n  };\n}\n\nfunction insert<T>(state: ListState<T>, index: number, ...values: T[]): ListState<T> {\n  return {\n    ...state,\n    items: [\n      ...state.items.slice(0, index),\n      ...values,\n      ...state.items.slice(index)\n    ]\n  };\n}\n\nfunction move<T>(state: ListState<T>, indices: number[], toIndex: number): ListState<T> {\n  // Shift the target down by the number of items being moved from before the target\n  for (let index of indices) {\n    if (index < toIndex) {\n      toIndex--;\n    }\n  }\n\n  let moves = indices.map(from => ({\n    from,\n    to: toIndex++\n  }));\n\n  // Shift later from indices down if they have a larger index\n  for (let i = 0; i < moves.length; i++) {\n    let a = moves[i].from;\n    for (let j = i; j < moves.length; j++) {\n      let b = moves[j].from;\n\n      if (b > a) {\n        moves[j].from--;\n      }\n    }\n  }\n\n  // Interleave the moves so they can be applied one by one rather than all at once\n  for (let i = 0; i < moves.length; i++) {\n    let a = moves[i];\n    for (let j = moves.length - 1; j > i; j--) {\n      let b = moves[j];\n\n      if (b.from < a.to) {\n        a.to++;\n      } else {\n        b.from++;\n      }\n    }\n  }\n\n  let copy = state.items.slice();\n  for (let move of moves) {\n    let [item] = copy.splice(move.from, 1);\n    copy.splice(move.to, 0, item);\n  }\n\n  return {\n    ...state,\n    items: copy\n  };\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {createListActions, ListData, ListState} from './useListData';\nimport {Key, Reducer, useEffect, useReducer} from 'react';\nimport {LoadingState, Selection, SortDescriptor} from '@react-types/shared';\n\nexport interface AsyncListOptions<T, C> {\n  /** The keys for the initially selected items. */\n  initialSelectedKeys?: Iterable<Key>,\n  /** The initial sort descriptor. */\n  initialSortDescriptor?: SortDescriptor,\n  /** The initial filter text. */\n  initialFilterText?: string,\n  /** A function that returns a unique key for an item object. */\n  getKey?: (item: T) => Key,\n  /** A function that loads the data for the items in the list. */\n  load: AsyncListLoadFunction<T, C>,\n  /**\n   * An optional function that performs sorting. If not provided,\n   * then `sortDescriptor` is passed to the `load` function.\n   */\n  sort?: AsyncListLoadFunction<T, C>\n}\n\ntype AsyncListLoadFunction<T, C> = (state: AsyncListLoadOptions<T, C>) => AsyncListStateUpdate<T, C> | Promise<AsyncListStateUpdate<T, C>>;\n\ninterface AsyncListLoadOptions<T, C> {\n  /** The items currently in the list. */\n  items: T[],\n  /** The keys of the currently selected items in the list. */\n  selectedKeys: Selection,\n  /** The current sort descriptor for the list. */\n  sortDescriptor: SortDescriptor,\n  /** An abort signal used to notify the load function that the request has been aborted. */\n  signal: AbortSignal,\n  /** The pagination cursor returned from the last page load. */\n  cursor?: C,\n  /** The current filter text used to perform server side filtering. */\n  filterText?: string,\n  /** The current loading state of the list. */\n  loadingState?: LoadingState\n}\n\ninterface AsyncListStateUpdate<T, C> {\n  /** The new items to append to the list. */\n  items: Iterable<T>,\n  /** The keys to add to the selection. */\n  selectedKeys?: Iterable<Key>,\n  /** The sort descriptor to set. */\n  sortDescriptor?: SortDescriptor,\n  /** The pagination cursor to be used for the next page load. */\n  cursor?: C,\n  /** The updated filter text for the list. */\n  filterText?: string\n}\n\ninterface AsyncListState<T, C> extends ListState<T> {\n  state: LoadingState,\n  items: T[],\n  // disabledKeys?: Iterable<Key>,\n  selectedKeys: Selection,\n  // selectedKey?: Key,\n  // expandedKeys?: Iterable<Key>,\n  sortDescriptor?: SortDescriptor,\n  error?: Error,\n  abortController?: AbortController,\n  cursor?: C\n}\n\ntype ActionType = 'success' | 'error' | 'loading' | 'loadingMore' | 'sorting' | 'update' | 'filtering';\ninterface Action<T, C> {\n  type: ActionType,\n  items?: Iterable<T>,\n  selectedKeys?: Iterable<Key>,\n  sortDescriptor?: SortDescriptor,\n  error?: Error,\n  abortController?: AbortController,\n  updater?: (state: ListState<T>) => ListState<T>,\n  cursor?: C,\n  filterText?: string\n}\n\nexport interface AsyncListData<T> extends ListData<T> {\n  /** Whether data is currently being loaded. */\n  isLoading: boolean,\n  /** If loading data failed, then this contains the error that occurred. */\n  error?: Error,\n  // disabledKeys?: Set<Key>,\n  // selectedKey?: Key,\n  // expandedKeys?: Set<Key>,\n  /** The current sort descriptor for the list. */\n  sortDescriptor?: SortDescriptor,\n\n  /** Reloads the data in the list. */\n  reload(): void,\n  /** Loads the next page of data in the list. */\n  loadMore(): void,\n  /** Triggers sorting for the list. */\n  sort(descriptor: SortDescriptor): void,\n  /** The current loading state for the list. */\n  loadingState: LoadingState\n}\n\nfunction reducer<T, C>(data: AsyncListState<T, C>, action: Action<T, C>): AsyncListState<T, C> {\n  let selectedKeys;\n  switch (data.state) {\n    case 'idle':\n    case 'error':\n      switch (action.type) {\n        case 'loading':\n        case 'loadingMore':\n        case 'sorting':\n        case 'filtering':\n          return {\n            ...data,\n            filterText: action.filterText ?? data.filterText,\n            state: action.type,\n            // Reset items to an empty list if loading, but not when sorting.\n            items: action.type === 'loading' ? [] : data.items,\n            sortDescriptor: action.sortDescriptor ?? data.sortDescriptor,\n            abortController: action.abortController\n          };\n        case 'update':\n          return {\n            ...data,\n            ...action.updater(data)\n          };\n        case 'success':\n        case 'error':\n          return data;\n        default:\n          throw new Error(`Invalid action \"${action.type}\" in state \"${data.state}\"`);\n      }\n    case 'loading':\n    case 'sorting':\n    case 'filtering':\n      switch (action.type) {\n        case 'success':\n          // Ignore if there is a newer abortcontroller in state.\n          // This means that multiple requests were going at once.\n          // We want to take only the latest result.\n          if (action.abortController !== data.abortController) {\n            return data;\n          }\n\n          selectedKeys = action.selectedKeys ?? data.selectedKeys;\n          return {\n            ...data,\n            filterText: action.filterText ?? data.filterText,\n            state: 'idle',\n            items: [...action.items],\n            selectedKeys: selectedKeys === 'all' ? 'all' : new Set(selectedKeys),\n            sortDescriptor: action.sortDescriptor ?? data.sortDescriptor,\n            abortController: null,\n            cursor: action.cursor\n          };\n        case 'error':\n          if (action.abortController !== data.abortController) {\n            return data;\n          }\n\n          return {\n            ...data,\n            state: 'error',\n            error: action.error,\n            abortController: null\n          };\n        case 'loading':\n        case 'loadingMore':\n        case 'sorting':\n        case 'filtering':\n          // We're already loading, and another load was triggered at the same time.\n          // We need to abort the previous load and start a new one.\n          data.abortController.abort();\n          return {\n            ...data,\n            filterText: action.filterText ?? data.filterText,\n            state: action.type,\n            // Reset items to an empty list if loading, but not when sorting.\n            items: action.type === 'loading' ? [] : data.items,\n            abortController: action.abortController\n          };\n        case 'update':\n          // We're already loading, and an update happened at the same time (e.g. selectedKey changed).\n          // Update data but don't abort previous load.\n          return {\n            ...data,\n            ...action.updater(data)\n          };\n        default:\n          throw new Error(`Invalid action \"${action.type}\" in state \"${data.state}\"`);\n      }\n    case 'loadingMore':\n      switch (action.type) {\n        case 'success':\n          selectedKeys = (data.selectedKeys === 'all' || action.selectedKeys === 'all')\n            ? 'all'\n            : new Set([...data.selectedKeys, ...(action.selectedKeys ?? [])]);\n          // Append the new items\n          return {\n            ...data,\n            state: 'idle',\n            items: [...data.items, ...action.items],\n            selectedKeys,\n            sortDescriptor: action.sortDescriptor ?? data.sortDescriptor,\n            abortController: null,\n            cursor: action.cursor\n          };\n        case 'error':\n          if (action.abortController !== data.abortController) {\n            return data;\n          }\n\n          return {\n            ...data,\n            state: 'error',\n            error: action.error\n          };\n        case 'loading':\n        case 'sorting':\n        case 'filtering':\n          // We're already loading more, and another load was triggered at the same time.\n          // We need to abort the previous load more and start a new one.\n          data.abortController.abort();\n          return {\n            ...data,\n            filterText: action.filterText ?? data.filterText,\n            state: action.type,\n            // Reset items to an empty list if loading, but not when sorting.\n            items: action.type === 'loading' ? [] : data.items,\n            abortController: action.abortController\n          };\n        case 'loadingMore':\n          // If already loading more and another loading more is triggered, abort the new load more since\n          // it is a duplicate request since the cursor hasn't been updated.\n          // Do not overwrite the data.abortController\n          action.abortController.abort();\n\n          return data;\n        case 'update':\n          // We're already loading, and an update happened at the same time (e.g. selectedKey changed).\n          // Update data but don't abort previous load.\n          return {\n            ...data,\n            ...action.updater(data)\n          };\n        default:\n          throw new Error(`Invalid action \"${action.type}\" in state \"${data.state}\"`);\n      }\n    default:\n      throw new Error(`Invalid state \"${data.state}\"`);\n  }\n}\n\n/**\n * Manages state for an immutable async loaded list data structure, and provides convenience methods to\n * update the data over time. Manages loading and error states, pagination, and sorting.\n */\nexport function useAsyncList<T, C = string>(options: AsyncListOptions<T, C>): AsyncListData<T> {\n  const {\n    load,\n    sort,\n    initialSelectedKeys,\n    initialSortDescriptor,\n    getKey = (item: any) => item.id || item.key,\n    initialFilterText = ''\n  } = options;\n\n  let [data, dispatch] = useReducer<Reducer<AsyncListState<T, C>, Action<T, C>>>(reducer, {\n    state: 'idle',\n    error: null,\n    items: [],\n    selectedKeys: initialSelectedKeys === 'all' ? 'all' : new Set(initialSelectedKeys),\n    sortDescriptor: initialSortDescriptor,\n    filterText: initialFilterText\n  });\n\n  const dispatchFetch = async (action: Action<T, C>, fn: AsyncListLoadFunction<T, C>) => {\n    let abortController = new AbortController();\n    try {\n      dispatch({...action, abortController});\n      let previousFilterText = action.filterText ?? data.filterText;\n\n      let response = await fn({\n        items: data.items.slice(),\n        selectedKeys: data.selectedKeys,\n        sortDescriptor: action.sortDescriptor ?? data.sortDescriptor,\n        signal: abortController.signal,\n        cursor: action.type === 'loadingMore' ? data.cursor : null,\n        filterText: previousFilterText\n      });\n\n      let filterText = response.filterText ?? previousFilterText;\n      dispatch({type: 'success', ...response, abortController});\n\n      // Fetch a new filtered list if filterText is updated via `load` response func rather than list.setFilterText\n      // Only do this if not aborted (e.g. user triggers another filter action before load completes)\n      if (filterText && (filterText !== previousFilterText) && !abortController.signal.aborted) {\n        dispatchFetch({type: 'filtering', filterText}, load);\n      }\n    } catch (e) {\n      dispatch({type: 'error', error: e, abortController});\n    }\n  };\n\n  useEffect(() => {\n    dispatchFetch({type: 'loading'}, load);\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  return {\n    items: data.items,\n    selectedKeys: data.selectedKeys,\n    sortDescriptor: data.sortDescriptor,\n    isLoading: data.state === 'loading' || data.state === 'loadingMore' || data.state === 'sorting' || data.state === 'filtering',\n    loadingState: data.state,\n    error: data.error,\n    filterText: data.filterText,\n    getItem(key: Key) {\n      return data.items.find(item => getKey(item) === key);\n    },\n    reload() {\n      dispatchFetch({type: 'loading'}, load);\n    },\n    loadMore() {\n      // Ignore if already loading more or if performing server side filtering.\n      if (data.state === 'loadingMore' || data.state === 'filtering' || data.cursor == null) {\n        return;\n      }\n\n      dispatchFetch({type: 'loadingMore'}, load);\n    },\n    sort(sortDescriptor: SortDescriptor) {\n      dispatchFetch({type: 'sorting', sortDescriptor}, sort || load);\n    },\n    ...createListActions({...options, getKey, cursor: data.cursor}, fn => {\n      dispatch({type: 'update', updater: fn});\n    }),\n    setFilterText(filterText: string) {\n      dispatchFetch({type: 'filtering', filterText}, load);\n    }\n  };\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Key, useMemo, useState} from 'react';\n\nexport interface TreeOptions<T extends object> {\n  /** Initial root items in the tree. */\n  initialItems?: T[],\n  /** The keys for the initially selected items. */\n  initialSelectedKeys?: Iterable<Key>,\n  /** A function that returns a unique key for an item object. */\n  getKey?: (item: T) => Key,\n  /** A function that returns the children for an item object. */\n  getChildren?: (item: T) => T[]\n}\n\ninterface TreeNode<T extends object> {\n  /** A unique key for the tree node. */\n  key: Key,\n  /** The key of the parent node. */\n  parentKey: Key,\n  /** The value object for the tree node. */\n  value: T,\n  /** Children of the tree node. */\n  children: TreeNode<T>[]\n}\n\nexport interface TreeData<T extends object> {\n  /** The root nodes in the tree. */\n  items: TreeNode<T>[],\n\n  /** The keys of the currently selected items in the tree. */\n  selectedKeys: Set<Key>,\n\n  /** Sets the selected keys. */\n  setSelectedKeys(keys: Set<Key>): void,\n\n  /**\n   * Gets a node from the tree by key.\n   * @param key - The key of the item to retrieve.\n   */\n  getItem(key: Key): TreeNode<T>,\n\n  /**\n   * Inserts an item into a parent node as a child.\n   * @param parentKey - The key of the parent item to insert into. `null` for the root.\n   * @param index - The index within the parent to insert into.\n   * @param value - The value to insert.\n   */\n  insert(parentKey: Key | null, index: number, ...values: T[]): void,\n\n  /**\n   * Inserts items into the list before the item at the given key.\n   * @param key - The key of the item to insert before.\n   * @param values - The values to insert.\n   */\n  insertBefore(key: Key, ...values: T[]): void,\n\n  /**\n   * Inserts items into the list after the item at the given key.\n   * @param key - The key of the item to insert after.\n   * @param values - The values to insert.\n   */\n  insertAfter(key: Key, ...values: T[]): void,\n\n  /**\n   * Appends an item into a parent node as a child.\n   * @param parentKey - The key of the parent item to insert into. `null` for the root.\n   * @param value - The value to insert.\n   */\n  append(parentKey: Key | null, ...values: T[]): void,\n\n  /**\n   * Prepends an item into a parent node as a child.\n   * @param parentKey - The key of the parent item to insert into. `null` for the root.\n   * @param value - The value to insert.\n   */\n  prepend(parentKey: Key | null, ...value: T[]): void,\n\n  /**\n   * Removes an item from the tree by its key.\n   * @param key - The key of the item to remove.\n   */\n  remove(...keys: Key[]): void,\n\n  /**\n   * Removes all items from the tree that are currently\n   * in the set of selected items.\n   */\n  removeSelectedItems(): void,\n\n  /**\n   * Moves an item within the tree.\n   * @param key - The key of the item to move.\n   * @param toParentKey - The key of the new parent to insert into.\n   * @param index - The index within the new parent to insert at.\n   */\n  move(key: Key, toParentKey: Key, index: number): void,\n\n  /**\n   * Updates an item in the tree.\n   * @param key - The key of the item to update.\n   * @param newValue - The new value for the item.\n   */\n  update(key: Key, newValue: T): void\n}\n\n/**\n * Manages state for an immutable tree data structure, and provides convenience methods to\n * update the data over time.\n */\nexport function useTreeData<T extends object>(options: TreeOptions<T>): TreeData<T> {\n  let {\n    initialItems = [],\n    initialSelectedKeys,\n    getKey = (item: any) => item.id || item.key,\n    getChildren = (item: any) => item.children\n  } = options;\n  let map = useMemo(() => new Map<Key, TreeNode<T>>(), []);\n\n  // We only want to compute this on initial render.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  let initialNodes = useMemo(() => buildTree(initialItems), []);\n  let [items, setItems] = useState(initialNodes);\n  let [selectedKeys, setSelectedKeys] = useState(new Set<Key>(initialSelectedKeys || []));\n\n  function buildTree(initialItems: T[] = [], parentKey?: Key | null) {\n    return initialItems.map(item => {\n      let node: TreeNode<T> = {\n        key: getKey(item),\n        parentKey: parentKey,\n        value: item,\n        children: null\n      };\n\n      node.children = buildTree(getChildren(item), node.key);\n      map.set(node.key, node);\n      return node;\n    });\n  }\n\n  function updateTree(items: TreeNode<T>[], key: Key, update: (node: TreeNode<T>) => TreeNode<T>) {\n    let node = map.get(key);\n    if (!node) {\n      return items;\n    }\n\n    // Create a new node. If null, then delete the node, otherwise replace.\n    let newNode = update(node);\n    if (newNode == null) {\n      deleteNode(node);\n    } else {\n      addNode(newNode);\n    }\n\n    // Walk up the tree and update each parent to refer to the new chilren.\n    while (node.parentKey) {\n      let nextParent = map.get(node.parentKey);\n      let copy: TreeNode<T> = {\n        key: nextParent.key,\n        parentKey: nextParent.parentKey,\n        value: nextParent.value,\n        children: null\n      };\n\n      let children = nextParent.children;\n      if (newNode == null) {\n        children = children.filter(c => c !== node);\n      }\n\n      copy.children = children.map(child => {\n        if (child === node) {\n          return newNode;\n        }\n\n        return child;\n      });\n\n      map.set(copy.key, copy);\n\n      newNode = copy;\n      node = nextParent;\n    }\n\n    if (newNode == null) {\n      items = items.filter(c => c !== node);\n    }\n\n    return items.map(item => {\n      if (item === node) {\n        return newNode;\n      }\n\n      return item;\n    });\n  }\n\n  function addNode(node: TreeNode<T>) {\n    map.set(node.key, node);\n    for (let child of node.children) {\n      addNode(child);\n    }\n  }\n\n  function deleteNode(node: TreeNode<T>) {\n    map.delete(node.key);\n    for (let child of node.children) {\n      deleteNode(child);\n    }\n  }\n\n  return {\n    items,\n    selectedKeys,\n    setSelectedKeys,\n    getItem(key: Key) {\n      return map.get(key);\n    },\n    insert(parentKey: Key | null, index: number, ...values: T[]) {\n      setItems(items => {\n        let nodes = buildTree(values, parentKey);\n\n        // If parentKey is null, insert into the root.\n        if (parentKey == null) {\n          return [\n            ...items.slice(0, index),\n            ...nodes,\n            ...items.slice(index)\n          ];\n        }\n\n        // Otherwise, update the parent node and its ancestors.\n        return updateTree(items, parentKey, parentNode => ({\n          key: parentNode.key,\n          parentKey: parentNode.parentKey,\n          value: parentNode.value,\n          children: [\n            ...parentNode.children.slice(0, index),\n            ...nodes,\n            ...parentNode.children.slice(index)\n          ]\n        }));\n      });\n    },\n    insertBefore(key: Key, ...values: T[]): void {\n      let node = map.get(key);\n      if (!node) {\n        return;\n      }\n\n      let parentNode = map.get(node.parentKey);\n      let nodes = parentNode ? parentNode.children : items;\n      let index = nodes.indexOf(node);\n      this.insert(parentNode?.key, index, ...values);\n    },\n    insertAfter(key: Key, ...values: T[]): void {\n      let node = map.get(key);\n      if (!node) {\n        return;\n      }\n\n      let parentNode = map.get(node.parentKey);\n      let nodes = parentNode ? parentNode.children : items;\n      let index = nodes.indexOf(node);\n      this.insert(parentNode?.key, index + 1, ...values);\n    },\n    prepend(parentKey: Key | null, ...values: T[]) {\n      this.insert(parentKey, 0, ...values);\n    },\n    append(parentKey: Key | null, ...values: T[]) {\n      if (parentKey == null) {\n        this.insert(null, items.length, ...values);\n      } else {\n        let parentNode = map.get(parentKey);\n        if (!parentNode) {\n          return;\n        }\n\n        this.insert(parentKey, parentNode.children.length, ...values);\n      }\n    },\n    remove(...keys: Key[]) {\n      let newItems = items;\n      for (let key of keys) {\n        newItems = updateTree(newItems, key, () => null);\n      }\n\n      setItems(newItems);\n\n      let selection = new Set(selectedKeys);\n      for (let key of selectedKeys) {\n        if (!map.has(key)) {\n          selection.delete(key);\n        }\n      }\n\n      setSelectedKeys(selection);\n    },\n    removeSelectedItems() {\n      this.remove(...selectedKeys);\n    },\n    move(key: Key, toParentKey: Key, index: number) {\n      setItems(items => {\n        let node = map.get(key);\n        if (!node) {\n          return items;\n        }\n\n        items = updateTree(items, key, () => null);\n\n        const movedNode = {\n          ...node,\n          parentKey: toParentKey\n        };\n\n        return updateTree(items, toParentKey, parentNode => ({\n          key: parentNode.key,\n          parentKey: parentNode.parentKey,\n          value: parentNode.value,\n          children: [\n            ...parentNode.children.slice(0, index),\n            movedNode,\n            ...parentNode.children.slice(index)\n          ]\n        }));\n      });\n    },\n    update(oldKey: Key, newValue: T) {\n      setItems(items => updateTree(items, oldKey, oldNode => {\n        let node: TreeNode<T> = {\n          key: oldNode.key,\n          parentKey: oldNode.parentKey,\n          value: newValue,\n          children: null\n        };\n\n        node.children = buildTree(getChildren(newValue), node.key);\n        return node;\n      }));\n    }\n  };\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}