{"ast":null,"code":"'use strict';\n\nlet http = require('http');\nlet https = require('https');\nlet Buffer = require('buffer').Buffer;\nlet url = require('url');\nlet Encoder = require('./encoder').Encoder;\nlet zlib = require('zlib');\nlet Json = require('./serializer/json').Json;\nlet Text = require('./serializer/text').Text;\nlet Multipart = require('./serializer/multipart').Multipart;\nlet FormEncoded = require('./serializer/form_encoded').FormEncoded;\nconst THIRTY_SECONDS = 10 * 3000;\nclass HttpError extends Error {\n  constructor(response) {\n    super();\n    this.message = response.message || response.text || 'An unknown error occured.';\n    this.statusCode = response.statusCode;\n    this.headers = response.headers;\n    this._originalError = response;\n  }\n}\nclass HttpClient {\n  constructor(environment) {\n    this.environment = environment;\n    this._injectors = [];\n    this.encoder = new Encoder([new Json(), new Text(), new Multipart(), new FormEncoded()]);\n  }\n  getUserAgent() {\n    return 'PayPalHttp-Node HTTP/1.1';\n  }\n  getTimeout() {\n    return THIRTY_SECONDS;\n  }\n  addInjector(injector) {\n    if (typeof injector !== 'function' || injector.length !== 1) {\n      throw new Error('injector must be a function that takes one argument');\n    }\n    this._injectors.push(injector);\n  }\n  formatHeaders(headers) {\n    let formattedHeader = {};\n    Object.keys(headers).forEach(function (key) {\n      if (key != null) {\n        if (key.toLowerCase() === 'content-type') {\n          formattedHeader[key.toLowerCase()] = headers[key].toLowerCase();\n        } else {\n          formattedHeader[key.toLowerCase()] = headers[key];\n        }\n      }\n    });\n    return formattedHeader;\n  }\n  mapHeader(rawHeaders, formattedHeaders) {\n    Object.keys(rawHeaders).forEach(function (key) {\n      if (key != null) {\n        let lCase = key.toLowerCase();\n        if (formattedHeaders[lCase] != null) {\n          rawHeaders[key] = formattedHeaders[lCase];\n        }\n      }\n    });\n    return rawHeaders;\n  }\n  execute(req) {\n    let request = Object.assign({}, req);\n    if (!request.headers) {\n      request.headers = {};\n    }\n    let injectorPromises = this._injectors.map(function (injector) {\n      return injector(request);\n    });\n    let requestBody, requestAborted;\n    let client = this.environment.baseUrl.startsWith('https') ? https : http;\n    let parsedUrl = url.parse(this.environment.baseUrl);\n    request.host = parsedUrl.hostname;\n    request.port = parsedUrl.port;\n    let formattedHeaders = this.formatHeaders(request.headers);\n    if (!formattedHeaders['user-agent'] || formattedHeaders['user-agent'] === 'Node') {\n      request.headers['User-Agent'] = this.getUserAgent();\n    }\n    if (request.body) {\n      let rawHeaders = request.headers;\n      request.headers = formattedHeaders;\n      requestBody = this.encoder.serializeRequest(request);\n      request.headers = this.mapHeader(rawHeaders, formattedHeaders);\n      request.headers['Content-Length'] = Buffer.byteLength(requestBody).toString();\n    }\n    if (request.verb) {\n      request.method = request.verb;\n    }\n    return new Promise((resolve, reject) => {\n      return Promise.all(injectorPromises).then(() => {\n        let theRequest = client.request(request, response => {\n          let buffers = [];\n          response.on('data', responseBody => {\n            buffers.push(responseBody);\n          });\n          response.on('end', () => {\n            formattedHeaders = this.formatHeaders(response.headers);\n            let contentEncoding = formattedHeaders['content-encoding'];\n            let body = Buffer.concat(buffers);\n            if (contentEncoding === 'gzip') {\n              body = zlib.gunzipSync(body);\n            }\n            body = body.toString('utf8');\n            if (response.statusCode >= 200 && response.statusCode <= 299) {\n              resolve(this._parseResponse(body, response, formattedHeaders));\n            } else {\n              reject(new HttpError({\n                text: body,\n                statusCode: response.statusCode,\n                headers: response.headers\n              }));\n            }\n          });\n          response.on('error', reject);\n        });\n        function timeoutHandler() {\n          theRequest.abort();\n          requestAborted = true;\n          reject(new Error('Request timed out'));\n        }\n        theRequest.setTimeout(this.getTimeout(), timeoutHandler);\n        let requestSocket = null;\n        theRequest.on('socket', socket => {\n          requestSocket = socket;\n        });\n        theRequest.on('error', error => {\n          if (requestAborted) {\n            return;\n          }\n          requestSocket.removeListener('timeout', timeoutHandler);\n          reject(error);\n        });\n        if (requestBody) {\n          theRequest.write(requestBody);\n        }\n        theRequest.end();\n      }).catch(reject);\n    });\n  }\n  _parseResponse(body, response, formattedHeaders) {\n    var data = {\n      statusCode: response.statusCode,\n      headers: response.headers\n    };\n    if (body) {\n      data.result = this.encoder.deserializeResponse(body, formattedHeaders);\n    }\n    return data;\n  }\n}\nmodule.exports = {\n  HttpClient: HttpClient\n};","map":{"version":3,"names":["http","require","https","Buffer","url","Encoder","zlib","Json","Text","Multipart","FormEncoded","THIRTY_SECONDS","HttpError","Error","constructor","response","message","text","statusCode","headers","_originalError","HttpClient","environment","_injectors","encoder","getUserAgent","getTimeout","addInjector","injector","length","push","formatHeaders","formattedHeader","Object","keys","forEach","key","toLowerCase","mapHeader","rawHeaders","formattedHeaders","lCase","execute","req","request","assign","injectorPromises","map","requestBody","requestAborted","client","baseUrl","startsWith","parsedUrl","parse","host","hostname","port","body","serializeRequest","byteLength","toString","verb","method","Promise","resolve","reject","all","then","theRequest","buffers","on","responseBody","contentEncoding","concat","gunzipSync","_parseResponse","timeoutHandler","abort","setTimeout","requestSocket","socket","error","removeListener","write","end","catch","data","result","deserializeResponse","module","exports"],"sources":["C:/Users/gonca/my-app/node_modules/@paypal/paypalhttp/lib/paypalhttp/http_client.js"],"sourcesContent":["'use strict';\n\nlet http = require('http');\nlet https = require('https');\nlet Buffer = require('buffer').Buffer;\nlet url = require('url');\nlet Encoder = require('./encoder').Encoder;\nlet zlib = require('zlib');\nlet Json = require('./serializer/json').Json;\nlet Text = require('./serializer/text').Text;\nlet Multipart = require('./serializer/multipart').Multipart;\nlet FormEncoded = require('./serializer/form_encoded').FormEncoded;\n\nconst THIRTY_SECONDS = 10 * 3000;\n\nclass HttpError extends Error {\n  constructor(response) {\n    super();\n\n    this.message = response.message || response.text || 'An unknown error occured.';\n    this.statusCode = response.statusCode;\n    this.headers = response.headers;\n    this._originalError = response;\n  }\n}\n\nclass HttpClient {\n\n  constructor(environment) {\n    this.environment = environment;\n    this._injectors = [];\n    this.encoder = new Encoder([new Json(), new Text(), new Multipart(), new FormEncoded()]);\n  }\n\n  getUserAgent() {\n    return 'PayPalHttp-Node HTTP/1.1';\n  }\n\n  getTimeout() {\n    return THIRTY_SECONDS;\n  }\n\n  addInjector(injector) {\n    if (typeof injector !== 'function' || injector.length !== 1) {\n      throw new Error('injector must be a function that takes one argument');\n    }\n\n    this._injectors.push(injector);\n  }\n\n  formatHeaders(headers) {\n    let formattedHeader = {};\n\n    Object.keys(headers).forEach(function (key) {\n      if (key != null) {\n        if (key.toLowerCase() === 'content-type')\t{\n          formattedHeader[key.toLowerCase()] = headers[key].toLowerCase();\n        } else {\n          formattedHeader[key.toLowerCase()] = headers[key];\n        }\n      }\n    });\n    return formattedHeader;\n  }\n\n  mapHeader(rawHeaders, formattedHeaders) {\n    Object.keys(rawHeaders).forEach(function (key) {\n      if (key != null) {\n        let lCase = key.toLowerCase();\n\n        if (formattedHeaders[lCase] != null) {\n          rawHeaders[key] = formattedHeaders[lCase];\n        }\n      }\n    });\n    return rawHeaders;\n  }\n\n  execute(req) {\n    let request = Object.assign({}, req);\n\n    if (!request.headers) {\n      request.headers = {};\n    }\n\n    let injectorPromises = this._injectors.map(function (injector) {\n      return injector(request);\n    });\n\n    let requestBody, requestAborted;\n    let client = this.environment.baseUrl.startsWith('https') ? https : http;\n\n    let parsedUrl = url.parse(this.environment.baseUrl);\n\n    request.host = parsedUrl.hostname;\n    request.port = parsedUrl.port;\n    let formattedHeaders = this.formatHeaders(request.headers);\n\n    if (!formattedHeaders['user-agent'] || formattedHeaders['user-agent'] === 'Node') {\n      request.headers['User-Agent'] = this.getUserAgent();\n    }\n\n    if (request.body) {\n      let rawHeaders = request.headers;\n\n      request.headers = formattedHeaders;\n      requestBody = this.encoder.serializeRequest(request);\n      request.headers = this.mapHeader(rawHeaders, formattedHeaders);\n      request.headers['Content-Length'] = Buffer.byteLength(requestBody).toString();\n    }\n\n    if (request.verb) {\n      request.method = request.verb;\n    }\n\n    return new Promise((resolve, reject) => {\n      return Promise.all(injectorPromises).then(() => {\n        let theRequest = client.request(request, (response) => {\n          let buffers = [];\n\n          response.on('data', (responseBody) => {\n            buffers.push(responseBody);\n          });\n\n          response.on('end', () => {\n            formattedHeaders = this.formatHeaders(response.headers);\n            let contentEncoding = formattedHeaders['content-encoding'];\n\n            let body = Buffer.concat(buffers);\n\n            if (contentEncoding === 'gzip') {\n              body = zlib.gunzipSync(body);\n            }\n\n            body = body.toString('utf8');\n\n            if (response.statusCode >= 200 && response.statusCode <= 299) {\n              resolve(this._parseResponse(body, response, formattedHeaders));\n            } else {\n              reject(new HttpError({\n                text: body,\n                statusCode: response.statusCode,\n                headers: response.headers\n              }));\n            }\n          });\n\n          response.on('error', reject);\n        });\n\n        function timeoutHandler() {\n          theRequest.abort();\n          requestAborted = true;\n\n          reject(new Error('Request timed out'));\n        }\n\n        theRequest.setTimeout(this.getTimeout(), timeoutHandler);\n\n        let requestSocket = null;\n\n        theRequest.on('socket', (socket) => {\n          requestSocket = socket;\n        });\n\n        theRequest.on('error', (error) => {\n          if (requestAborted) { return; }\n          requestSocket.removeListener('timeout', timeoutHandler);\n\n          reject(error);\n        });\n\n        if (requestBody) {\n          theRequest.write(requestBody);\n        }\n        theRequest.end();\n      }).catch(reject);\n    });\n  }\n\n  _parseResponse(body, response, formattedHeaders) {\n    var data = {\n      statusCode: response.statusCode,\n      headers: response.headers\n    };\n\n    if (body) {\n      data.result = this.encoder.deserializeResponse(body, formattedHeaders);\n    }\n\n    return data;\n  }\n}\n\nmodule.exports = {HttpClient: HttpClient};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}